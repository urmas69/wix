
// <auto-generated>
// @formatter:off

namespace WixToolset.Harvesters
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;

    public class HarvesterFilter
    {
        private readonly object _lock = new object();
        private string _fileName;
        private string _startPath;
        private bool _isExclusive;
        private bool _isInclusive;
        private List<Regex> _keyList = new List<Regex>();

        public void Load(string fileName, string startPath)
        {
            _fileName = fileName ?? throw new ArgumentNullException(nameof(fileName));
            _startPath = startPath;
            ReloadKeyList();
        }

        private List<string> LoadKeyList()
        {
            _isInclusive = false;
            _isExclusive = false;

            List<string> list = new List<string>();

            var fileName = _fileName; // Path.Combine(cachePath, _fileName);
            if (!File.Exists(fileName))
            {
                //D($"File not found: {fileName}");
                return list;
            }

            Regex regInc = new Regex(@"^\+");
            Regex regEx = new Regex(@"^-");
            Regex regKey = new Regex(@"^[.\w\\:*]");
            Regex regComment = new Regex(@"^#");
            //Regex regReload = new(@"^[\+-]!");
            Regex regExit = new Regex(@"^<");

            foreach (var line in File.ReadLines(fileName))
            {
                if (regExit.IsMatch(line))
                    break;

                if (!_isExclusive && !_isInclusive && regInc.IsMatch(line))
                {
                    _isInclusive = true;
                    //IsReload = !regReload.IsMatch(line);
                }
                else if (!_isExclusive && !_isInclusive && regEx.IsMatch(line))
                {
                    _isExclusive = true;
                    //IsReload = !regReload.IsMatch(line);
                }
                else if (_isExclusive || _isInclusive)
                {
                    if (regComment.IsMatch(line))
                        continue;

                    if (regKey.IsMatch(line))
                        list.Add(line.Trim());
                    else
                        break;
                }
            }

            return list;
        }

        public bool IsFiltered(string name)
        {
            lock (_lock)
            {
                var contains = _keyList.Any(r => r.IsMatch(name)); //  .Contains(name);
                                                                   //return _isExclusive ? contains : !_isInclusive || !contains;
                if (_isInclusive) return !contains;
                if (_isExclusive) return contains;
                return false;
            }
        }

        public bool IsIncl(string name)
        {
            lock (_lock)
            {
                var contains = _keyList.Any(r => r.IsMatch(name)); //  .Contains(name);
                if (_isInclusive) return contains;
                if (_isExclusive) return !contains;
                return true;
            }
        }


        private void ReloadKeyList()
        {
            lock (_lock)
            {
                _keyList = LoadKeyList().Select(pattern =>
                {
                    var option = RegexOptions.Compiled;

                    if (pattern.StartsWith(@":"))
                    {
                        pattern = pattern.Substring(1);
                        option |= RegexOptions.IgnoreCase;
                    }

                    if (pattern.StartsWith(@".\"))
                        pattern = Path.Combine(_startPath, pattern.Substring(2));

                    return new Regex(Regex.Escape(pattern)
                                         .Replace(@"\*\*", ".*") // ** entspricht beliebigen Ebenen
                                         .Replace(@"\*", @"[^\\]*") // * entspricht beliebigen Zeichen innerhalb einer Ebene
                                         .Replace(@"\?", ".") // ? entspricht einem beliebigen Zeichen
                                                              //.Replace(@"\.", ".+")
                                     + "$", option);
                }).ToList();
                //D($"_keyList: {_keyList.Count}");
            }
        }
    }
}
