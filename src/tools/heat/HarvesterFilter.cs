
// <auto-generated>
// @formatter:off

namespace WixToolset.Harvesters
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;

    public class HarvesterFilter
    {
        enum Mode { Unknow, Incl, Excl }

        private readonly object _lock = new object();
        private string _fileName;
        private string _startPath;
        private string _fragment;

        private Mode _mode = Mode.Unknow;

        private bool _read;
        private List<Regex> _keyList = new List<Regex>();

        public void Load(string fileName, string startPath, string fragment = null)
        {
            Console.WriteLine($"HarvesterFilter load: {fileName} : {fragment}");
            _fileName = fileName ?? throw new ArgumentNullException(nameof(fileName));
            _startPath = startPath;
            _fragment = fragment;
            ReloadKeyList();
        }

        private HashSet<string> LoadKeyList()
        {
            _mode = Mode.Unknow;

            HashSet<string> list = new HashSet<string>();

            var fileName = _fileName; // Path.Combine(cachePath, _fileName);
            if (!File.Exists(fileName))
            {
                //D($"File not found: {fileName}");
                return list;
            }

            Regex regInc = new Regex($@"^\+{_fragment}");
            Regex regEx = new Regex($@"^-{_fragment}");
            Regex regKey = new Regex(@"^[.\w\\:*]");
            Regex regIgnore = new Regex(@"^[+-]");
            Regex regComment = new Regex(@"^#");
            //Regex regReload = new(@"^[\+-]!");
            Regex regExit = new Regex(@"^<");

            foreach (var line in File.ReadLines(fileName))
            {
                if (regExit.IsMatch(line)) break;

                if (regComment.IsMatch(line)) continue;

                if (!_read)
                {
                    if (regInc.IsMatch(line))
                    {
                        _read = true;
                        if (_mode == Mode.Unknow) _mode = Mode.Incl;
                    }
                    else if (regEx.IsMatch(line))
                    {
                        _read = true;
                        if (_mode == Mode.Unknow) _mode = Mode.Excl;
                    }
                    //IsReload = !regReload.IsMatch(line);
                }
                else if (_read)
                {
                    if (regIgnore.IsMatch(line)) continue;

                    if (regKey.IsMatch(line))
                        list.Add(line.Trim());
                    else
                        _read = false;
                }
            }

            return list;
        }

        public bool IsFiltered(string name)
        {
            lock (_lock)
            {
                var contains = _keyList.Any(r => r.IsMatch(name)); //  .Contains(name);

                return _mode switch
                {
                    //return _isExclusive ? contains : !_isInclusive || !contains;
                    Mode.Incl => !contains,
                    Mode.Excl => contains,
                    _ => false
                };
            }
        }

        public bool IsIncl(string name)
        {
            lock (_lock)
            {
                var contains = _keyList.Any(r => r.IsMatch(name)); //  .Contains(name);
                return _mode switch
                {
                    Mode.Incl => contains,
                    Mode.Excl => !contains,
                    _ => false
                };
            }
        }


        private void ReloadKeyList()
        {
            lock (_lock)
            {
                _keyList = LoadKeyList().Select(pattern =>
                {
                    var option = RegexOptions.Compiled;

                    if (pattern.StartsWith(@":"))
                    {
                        pattern = pattern.Substring(1);
                        option |= RegexOptions.IgnoreCase;
                    }

                    if (pattern.StartsWith(@".\"))
                        pattern = Path.Combine(_startPath, pattern.Substring(2));

                    return new Regex(Regex.Escape(pattern)
                                         .Replace(@"\*\*", ".*") // ** entspricht beliebigen Ebenen
                                         .Replace(@"\*", @"[^\\]*") // * entspricht beliebigen Zeichen innerhalb einer Ebene
                                         .Replace(@"\?", ".") // ? entspricht einem beliebigen Zeichen
                                                              //.Replace(@"\.", ".+")
                                     + "$", option);
                }).ToList();
                //D($"-- _keyList: {_keyList.Count}:{_mode}");
                //_keyList.Do(k => D($"+++ {k}"));
            }
        }

    }

}
